{
    "appName": "Java Interview Question Answer App",
    "version": "2.1",
    "aboutTitle": "About Us",
    "aboutDesc": "Java Interview Question Answer App is created for learning Java concepts with interview perspective. This app is created by <a href='http://www.fromdev.com'>Fromdev.com</a>. FromDev is a fast growing digital weblog that constantly publishes quality articles about interesting tutorials, noteworthy programming resources, online tips and tricks, books recommendation, practical and useful information for modern web developers and anyone interested in the web industry. To discuss questions and answers please visit <a href='http://www.fromdev.com'>Fromdev.com</a>.",
    "timestamp": "1234567",
    "senderEmail": "pima.support@gmail.com",
    "senderEmailPass" : "test1234",
    "receiverEmail": "pima.support@gmail.com",
    "qaList": [
        {
            "id": "1",
            "q": "What is immutable object in Java? Can you change values of a immutable object?",
            "a": "A Java object is considered immutable when its state cannot change after it is created. Use of immutable objects is widely accepted as a sound strategy for creating simple, reliable code. Immutable objects are particularly useful in concurrent applications. Since they cannot change state, they cannot be corrupted by thread interference or observed in an inconsistent state. java.lang.String and java.lang.Integer classes are the Examples of immutable objects from the Java Development Kit. Immutable objects simplify your program due to following characteristics : <ul><li>Immutable objects are simple to use test and construct.</li><li>Immutable objects are automatically thread-safe.</li><li>Immutable objects do not require a copy constructor. </li><li>Immutable objects do not require an implementation of clone. </li><li>Immutable objects allow hashCode to use lazy initialization, and to cache its return value.</li><li>Immutable objects do not need to be copied defensively when used as a field. </li><li>Immutable objects are good Map keys and Set elements (Since state of these objects must not change while stored in a collection).</li><li>Immutable objects have their class invariant established once upon construction, and it never needs to be checked again.</li><li>Immutable objects always have 'failure atomicity' (a term used by Joshua Bloch) : if an immutable object throws an exception, it's never left in an undesirable or indeterminate state.</li>",
            "category": "Core Java"
        },
        {
            "id": "2",
            "q": "Is Java Pass by Reference or Pass by Value?",
            "a": "<p>The Java Spec says that everything in Java is pass-by-value. There is no such thing as 'pass-by-reference' in Java. The difficult thing can be to understand that Java passes 'objects as references' passed by value.    This can certainly get confusing and I would recommend reading this article from an expert: <a href='http://javadude.com/articles/passbyvalue.htm'>http://javadude.com/articles/passbyvalue.htm</a> Also read this interesting thread with example on StackOverflow : <a href='http://stackoverflow.com/questions/40480/is-java-pass-by-reference'>Java Pass By Ref or Value</a></p>",
            "category": "Serialization"
        },
        {
            "id": "3",
            "q": "How to create a immutable object in Java? Does all property of immutable object needs to be final?",
            "a": "To create a object immutable You need to make the class final and all its member final so that once objects gets crated no one can modify its state. You can achieve same functionality by making member as non final but private and not modifying them except in constructor. Also its NOT necessary to have all the properties final since you can achieve same functionality by making member as non final but private and not modifying them except in constructor. ",
            "category": "Core Java"
        },
        {
            "id": "4",
            "q": "What is difference between String, StringBuffer and StringBuilder? When to use them?",
            "a": "<p>The main difference between the three most commonly used String classes as follows.   </p><ul><li>StringBuffer and StringBuilder objects are mutable whereas String class objects are immutable.</li><li>StringBuffer class implementation is synchronized while StringBuilder class is not synchronized. </li><li>Concatenation operator + is internally implemented by Java using either StringBuffer or StringBuilder. </li></ul><p>Criteria to choose among String, StringBuffer and StringBuilder</p><ul><li>If the Object value will not change in a scenario use String Class because a String object is immutable. </li><li>If the Object value can change and will only be modified from a single thread, use a StringBuilder because StringBuilder is unsynchronized(means faster). </li><li>If the Object value may change, and can be modified by multiple threads, use a StringBuffer because StringBuffer is thread safe(synchronized).</li></ul>",
            "category": "Core Java"
        },
        {
            "id": "5",
            "q": "Why String class is final or immutable?",
            "a": "<p>It is very useful to have strings implemented as final or immutable objects. Below are some advantages of String Immutability in Java  </p><ul><li>Immutable objects are thread-safe. Two threads can both work on an immutable object at the same time without any possibility of conflict. </li>The quick solution is to add these flags to JVM command line when Java runtime is started: <pre class='java' name='code'>-Xms1024m -Xmx1024m</pre><li><h3>java.lang.OutOfMemoryError: PermGen space </h3></li>The solution is to add these flags to JVM command line when Java runtime is started:   <pre class='java' name='code'>-XX:+CMSClassUnloadingEnabled-XX:+CMSPermGenSweepingEnabled</pre></ol><b>Long Term Solution</b>: Increasing the Start/Max Heap size or changing Garbage Collection options may not always be a long term solution for your Out Of Memory Error problem. Best approach is to understand the memory needs of your program and ensure it uses memory wisely and does not have leaks. You can use a Java memory profiler to determine what methods in your program are allocating large number of objects and then determine if there is a way to make sure they are no longer referenced, or to not allocate them in the first place. ",
            "category": "Core Java"
        },
        {
            "id": "8",
            "q": "What is the use of the finally block? Is finally block in Java guaranteed to be called? When finally block is NOT called?",
            "a": "<p>Finally is the block of code that executes always. The code in finally block will execute even if an exception is occurred. Finally block is NOT called in following conditions  </p><ul><li>If the JVM exits while the try or catch code is being executed, then the finally block may not execute. This may happen due to System.exit() call.</li><li>if the thread executing the try or catch code is interrupted or killed, the finally block may not execute even though the application as a whole continues. </li><li>If a exception is thrown in finally block and not handled then remaining code in finally block may not be executed.</li></ul>",
            "category": "Core Java"
        },
        {
            "id": "9",
            "q": "Why there are two Date classes; one in java.util package and another in java.sql?",
            "a": "<p>From the JavaDoc of java.sql.Date:  </p><blockquote>A thin wrapper around a millisecond value that allows JDBC to identify this as an SQL DATE value. A milliseconds value represents the number of milliseconds that have passed since January 1, 1970 00:00:00.000 GMT.    To conform with the definition of SQL DATE, the millisecond values wrapped inside a java.sql.Date instance must be 'normalized' by setting the hours, minutes, seconds, and milliseconds to zero.</blockquote><b>Explanation</b>: A java.util.Date represents date and time of day, a java.sql.Date only represents a date (the complement of java.sql.Date is java.sql.Time, which only represents a time of day, but also extends java.util.Date).",
            "category": "Core Java"
        },
        {
            "id": "10",
            "q": "What is Marker interface? How is it used in Java?",
            "a": "<p>The marker interface is a design pattern, used with languages that provide run-time type information about objects. It provides a way to associate metadata with a class where the language does not have explicit support for such metadata.    To use this pattern, a class implements a marker interface, and code that interact with instances of that class test for the existence of the interface. Whereas a typical interface specifies methods that an implementing class must support, a marker interface does not do so. The mere presence of such an interface indicates specific behavior on the part of the implementing class.   There can be some hybrid interfaces, which both act as markers and specify required methods, are possible but may prove confusing if improperly used. Java utilizes this pattern very well and the example interfaces are  </p><ul><li>java.io.Serializable - Serializability of a class is enabled by the class implementing the java.io.Serializable interface. The Java Classes that do not implement Serializable interface will not be able to serialize or deserializ their state. All subtypes of a serializable class are themselves serializable. The serialization interface has no methods or fields and serves only to identify the semantics of being serializable.</li></p>",
            "category": "Core Java"
        },
        {
            "id": "11",
            "q": "Need Help in learning Java?",
            "a": "Visit <href='http://www.fromdev.com/2012/02/java-interview-question-answer.html'>FromDev.com</a> to discuss and get help.",
            "category": "More"
        },
        {
            "id": "12",
            "q": "Looking for more Java questions or want to discuss?",
            "a": "Please update the questions to get latest set of questions.",
            "category": "More"
        }
    ]
}
