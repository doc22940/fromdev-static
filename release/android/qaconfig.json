{
    "appName": "Java Interview Question Answer App",
    "version": "2.1",
    "aboutTitle": "About Us",
    "aboutDesc": "Java Interview Question Answer App is created for learning Java concepts with interview perspective. This app is created by <a href='http://www.fromdev.com'>Fromdev.com</a>. FromDev is a fast growing digital weblog that constantly publishes quality articles about interesting tutorials, noteworthy programming resources, online tips and tricks, books recommendation, practical and useful information for modern web developers and anyone interested in the web industry. To discuss questions and answers please visit <a href='http://www.fromdev.com'>Fromdev.com</a>.",
    "timestamp": "1234567",
    "senderEmail": "pima.support@gmail.com",
    "senderEmailPass" : "test1234",
    "receiverEmail": "pima.support@gmail.com",
    "qaList": [
        {
            "id": "1",
            "q": "What is immutable object in Java? Can you change values of a immutable object?",
            "a": "A Java object is considered immutable when its state cannot change after it is created. Use of immutable objects is widely accepted as a sound strategy for creating simple, reliable code. Immutable objects are particularly useful in concurrent applications. Since they cannot change state, they cannot be corrupted by thread interference or observed in an inconsistent state. java.lang.String and java.lang.Integer classes are the Examples of immutable objects from the Java Development Kit. Immutable objects simplify your program due to following characteristics : <ul><li>Immutable objects are simple to use test and construct.</li><li>Immutable objects are automatically thread-safe.</li><li>Immutable objects do not require a copy constructor. </li><li>Immutable objects do not require an implementation of clone. </li><li>Immutable objects allow hashCode to use lazy initialization, and to cache its return value.</li><li>Immutable objects do not need to be copied defensively when used as a field. </li><li>Immutable objects are good Map keys and Set elements (Since state of these objects must not change while stored in a collection).</li><li>Immutable objects have their class invariant established once upon construction, and it never needs to be checked again.</li><li>Immutable objects always have 'failure atomicity' (a term used by Joshua Bloch) : if an immutable object throws an exception, it's never left in an undesirable or indeterminate state.</li>",
            "category": "Core Java"
        },
        {
            "id": "2",
            "q": "Is Java Pass by Reference or Pass by Value?",
            "a": "<p>The Java Spec says that everything in Java is pass-by-value. There is no such thing as 'pass-by-reference' in Java. The difficult thing can be to understand that Java passes 'objects as references' passed by value.    This can certainly get confusing and I would recommend reading this article from an expert: <a href='http://javadude.com/articles/passbyvalue.htm'>http://javadude.com/articles/passbyvalue.htm</a> Also read this interesting thread with example on StackOverflow : <a href='http://stackoverflow.com/questions/40480/is-java-pass-by-reference'>Java Pass By Ref or Value</a></p>",
            "category": "Serialization"
        },
        {
            "id": "3",
            "q": "How to create a immutable object in Java? Does all property of immutable object needs to be final?",
            "a": "To create a object immutable You need to make the class final and all its member final so that once objects gets crated no one can modify its state. You can achieve same functionality by making member as non final but private and not modifying them except in constructor. Also its NOT necessary to have all the properties final since you can achieve same functionality by making member as non final but private and not modifying them except in constructor. ",
            "category": "Core Java"
        },
        {
            "id": "4",
            "q": "What is difference between String, StringBuffer and StringBuilder? When to use them?",
            "a": "<p>The main difference between the three most commonly used String classes as follows.   </p><ul><li>StringBuffer and StringBuilder objects are mutable whereas String class objects are immutable.</li><li>StringBuffer class implementation is synchronized while StringBuilder class is not synchronized. </li><li>Concatenation operator + is internally implemented by Java using either StringBuffer or StringBuilder. </li></ul><p>Criteria to choose among String, StringBuffer and StringBuilder</p><ul><li>If the Object value will not change in a scenario use String Class because a String object is immutable. </li><li>If the Object value can change and will only be modified from a single thread, use a StringBuilder because StringBuilder is unsynchronized(means faster). </li><li>If the Object value may change, and can be modified by multiple threads, use a StringBuffer because StringBuffer is thread safe(synchronized).</li></ul>",
            "category": "Core Java"
        },
        {
            "id": "5",
            "q": "Why String class is final or immutable?",
            "a": "<p>It is very useful to have strings implemented as final or immutable objects. Below are some advantages of String Immutability in Java  </p><ul><li>Immutable objects are thread-safe. Two threads can both work on an immutable object at the same time without any possibility of conflict. </li>The quick solution is to add these flags to JVM command line when Java runtime is started: <pre class='java' name='code'>-Xms1024m -Xmx1024m</pre><li><h3>java.lang.OutOfMemoryError: PermGen space </h3></li>The solution is to add these flags to JVM command line when Java runtime is started:   <pre class='java' name='code'>-XX:+CMSClassUnloadingEnabled-XX:+CMSPermGenSweepingEnabled</pre></ol><b>Long Term Solution</b>: Increasing the Start/Max Heap size or changing Garbage Collection options may not always be a long term solution for your Out Of Memory Error problem. Best approach is to understand the memory needs of your program and ensure it uses memory wisely and does not have leaks. You can use a Java memory profiler to determine what methods in your program are allocating large number of objects and then determine if there is a way to make sure they are no longer referenced, or to not allocate them in the first place. ",
            "category": "Core Java"
        },
        {
            "id": "8",
            "q": "What is the use of the finally block? Is finally block in Java guaranteed to be called? When finally block is NOT called?",
            "a": "<p>Finally is the block of code that executes always. The code in finally block will execute even if an exception is occurred. Finally block is NOT called in following conditions  </p><ul><li>If the JVM exits while the try or catch code is being executed, then the finally block may not execute. This may happen due to System.exit() call.</li><li>if the thread executing the try or catch code is interrupted or killed, the finally block may not execute even though the application as a whole continues. </li><li>If a exception is thrown in finally block and not handled then remaining code in finally block may not be executed.</li></ul>",
            "category": "Core Java"
        },
        {
            "id": "9",
            "q": "Why there are two Date classes; one in java.util package and another in java.sql?",
            "a": "<p>From the JavaDoc of java.sql.Date:  </p><blockquote>A thin wrapper around a millisecond value that allows JDBC to identify this as an SQL DATE value. A milliseconds value represents the number of milliseconds that have passed since January 1, 1970 00:00:00.000 GMT.    To conform with the definition of SQL DATE, the millisecond values wrapped inside a java.sql.Date instance must be 'normalized' by setting the hours, minutes, seconds, and milliseconds to zero.</blockquote><b>Explanation</b>: A java.util.Date represents date and time of day, a java.sql.Date only represents a date (the complement of java.sql.Date is java.sql.Time, which only represents a time of day, but also extends java.util.Date).",
            "category": "Core Java"
        },
        {
            "id": "10",
            "q": "What is Marker interface? How is it used in Java?",
            "a": "<p>The marker interface is a design pattern, used with languages that provide run-time type information about objects. It provides a way to associate metadata with a class where the language does not have explicit support for such metadata.    To use this pattern, a class implements a marker interface, and code that interact with instances of that class test for the existence of the interface. Whereas a typical interface specifies methods that an implementing class must support, a marker interface does not do so. The mere presence of such an interface indicates specific behavior on the part of the implementing class.   There can be some hybrid interfaces, which both act as markers and specify required methods, are possible but may prove confusing if improperly used. Java utilizes this pattern very well and the example interfaces are  </p><ul><li>java.io.Serializable - Serializability of a class is enabled by the class implementing the java.io.Serializable interface. The Java Classes that do not implement Serializable interface will not be able to serialize or deserializ their state. All subtypes of a serializable class are themselves serializable. The serialization interface has no methods or fields and serves only to identify the semantics of being serializable.</li></p>",
            "category": "Core Java"
        },
        {
            "id": "11",
            "q": "Why main() in java is declared as public static void main? What if the main method is declared as private?",
            "a": "Public - main method is called by JVM to run the method which is outside the scope of project therefore the access specifier has to be public to permit call from anywhere outside the application static - When the JVM makes are call to the main method there is not object existing for the class being called therefore it has to have static method to allow invocation from class. void - Java is platform independent language therefore if it will return some value then the value may mean different to different platforms so unlike C it can not assume a behavior of returning value to the operating system. If main method is declared as private then - Program will compile properly but at run-time it will give 'Main method not public.' error. The only difference between experienced and inexperienced software developers is that the experienced ones realize when they're making a mistake.",
            "category": "Core Java"
        },
        {
            "id": "12",
            "q": "What are available drivers in JDBC?",
            "a": "<b>JDBC technology drivers fit into one of four categories: </b> <ol><li> A <i>JDBC-ODBC bridge</i> provides JDBC API access via one or more ODBC drivers. Note that some ODBC native code and in many cases native database client  code must be loaded on each client machine that uses this type of driver. Hence, this kind of driver is generally most appropriate when automatic installation and downloading of a Java technology application is not important.  <br></li><li>A <i>native-API partly Java technology-enabled driver</i> converts JDBC calls into calls on the client API for Oracle, Sybase, Informix, DB2, or other DBMS. Note that, like the bridge driver, this style of driver requires that some binary code be loaded on each client machine.</li><li>A <i>net-protocol fully Java technology-enabled driver</i> translates JDBC API calls into a DBMS-independent net protocol which is then translated to a DBMS protocol by a server. This net server middleware is able to connect all of its Java technology-based clients to many different databases. The specific protocol used depends on the vendor. In general, this is the most flexible JDBC API alternative. It is likely that all vendors of this solution will provide products suitable for Intranet use. In order for these products to also support Internet access they must handle the additional requirements for security, access through firewalls, etc., that the Web imposes. Several vendors are adding JDBC technology-based drivers to their existing database middleware products.</li><li>A <i>native-protocol fully Java technology-enabled driver</i> converts JDBC technology calls into the network protocol used by DBMSs directly. This allows a direct call from the client machine to the DBMS server and is a practical solution for Intranet access. Since many of these protocols are proprietary the database vendors themselves will be the primary source for this style of driver. Several database vendors have these in progress.</li></ol>",
            "category": "JDBC"
        },
        {
            "id": "13",
            "q": "What are the types of statements in JDBC?",
            "a": "<p>the JDBC API has 3 Interfaces, (1. Statement, 2. PreparedStatement, 3. CallableStatement ). The key features of these are as follows:  <b>Statement</b>  <ul><li>This interface is used for executing a static SQL statement and returning the results it produces. </li><li> The object of Statement class can be created using Connection.createStatement() method. </li></ul><b>PreparedStatement </b> <ul><li>A SQL statement is pre-compiled and stored in a PreparedStatement object.</li><li>This object can then be used to efficiently execute this statement multiple times.</li><li> The object of PreparedStatement class can be created using Connection.prepareStatement() method. This extends Statement interface. </li></ul><b>CallableStatement </b> <ul><li>This interface is used to execute SQL stored procedures.</li><li>  This extends PreparedStatement interface.</li><li> The object of CallableStatement class can be created using Connection.prepareCall() method.</li></ul></p>",
            "category": "JDBC"
        },
        {
            "id": "14",
            "q": "What is a stored procedure? How to call stored procedure using JDBC API?",
            "a": "<p>Stored procedure is a group of SQL statements that forms a logical unit and performs a particular task.  Stored Procedures are used to encapsulate a set of operations or queries to execute on database. Stored procedures can be compiled and executed with different parameters and results and may have any combination of input/output parameters.  Stored procedures can be called using CallableStatement class in JDBC API. Below code snippet shows how this can be achieved.  <pre name='code' class='java'>CallableStatement cs = con.prepareCall(\"{call MY_STORED_PROC_NAME}\");ResultSet rs = cs.executeQuery();</pre></p>",
            "category": "JDBC"
        },
        {
            "id": "15",
            "q": "What is a stored procedure? How to call stored procedure using JDBC API?",
            "a": "<p>Stored procedure is a group of SQL statements that forms a logical unit and performs a particular task.  Stored Procedures are used to encapsulate a set of operations or queries to execute on database. Stored procedures can be compiled and executed with different parameters and results and may have any combination of input/output parameters.  Stored procedures can be called using CallableStatement class in JDBC API. Below code snippet shows how this can be achieved.  <pre name='code' class='java'>CallableStatement cs = con.prepareCall(\"{call MY_STORED_PROC_NAME}\"); ResultSet rs = cs.executeQuery();</pre></p>",
            "category": "JDBC"
        },
        {
            "id": "16",
            "q": "What is Connection pooling? What are the advantages of using a connection pool?",
            "a": "<p>Connection Pooling is a technique used for sharing the server resources among requested clients. It was pioneered by database vendors to allow multiple clients to share a cached set of connection objects that provides access to a database. Getting connection and disconnecting are costly operation, which affects the application performance, so we should avoid creating multiple connection during multiple database interactions. A pool contains set of Database connections which are already connected, and any client who wants to use it can take it from pool and when done with using it can be returned back to the pool. Apart from performance this also saves you resources as there may be limited database connections available for your application. </p>",
            "category": "JDBC"
        },
        {
            "id": "17",
            "q": "How to do database connection using JDBC thin driver ?",
            "a": "<p>\nThis is one of the most commonly asked questions from JDBC fundamentals, and knowing all the steps of JDBC connection is important.  <pre name='code' class='java'>import java.sql.*;\nclass JDBCTest {\n  public static void main (String args []) throws Exception\n  {\n        //Load driver class\n        Class.forName (\"oracle.jdbc.driver.OracleDriver\");\n         //Create connection\n        Connection conn = DriverManager.getConnection\n             (\"jdbc:oracle:thin:@hostname:1526:testdb\", \"scott\", \"tiger\");\n                             // @machineName:port:SID,   userid,  password\n \n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.executeQuery(\"select 'Hi' from dual\");\n        while (rs.next())\n              System.out.println (rs.getString(1));   // Print col 1 => Hi\n         stmt.close();\n  }\n}\n</pre>\n</p>",
            "category": "JDBC"
        },
        {
            "id": "18",
            "q": "What does Class.forName() method do?",
            "a": "<p>\nMethod forName() is a static method of java.lang.Class. This can be used to dynamically load a class at run-time. Class.forName() loads the class if its not already loaded. It also executes the static block of loaded class. Then this method returns an instance of the loaded class. So a call to Class.forName('MyClass') is going to do following   \n\n- Load the class MyClass.\n- Execute any static block code of MyClass.\n- Return an instance of MyClass.\n\nJDBC Driver loading using Class.forName is a good example of best use of this method. The driver loading is done like this  \n\n<pre name='code' class='java'>Class.forName(\"org.mysql.Driver\");\n</pre>\nAll JDBC Drivers have a static block that registers itself with DriverManager and DriverManager has static initializer method registerDriver() which can be called in a static blocks of Driver class. A MySQL JDBC Driver has a static initializer which looks like this:  \n\n<pre name='code' class='java'>static {\n    try {\n        java.sql.DriverManager.registerDriver(new Driver());\n    } catch (SQLException E) {\n        throw new RuntimeException(\"Can't register driver!\");\n    }\n}\n</pre>\nClass.forName() loads driver class and executes the static block and the Driver registers itself with the DriverManager.\n</p>",
            "category": "JDBC"
        },
        {
            "id": "19",
            "q": "Which one will you use Statement or PreparedStatement? Or Which one to use when (Statement/PreparedStatement)? Compare PreparedStatement vs Statement.",
            "a": "<p>\nBy Java API definitions:  <b>Statement</b> is a object used for executing a static SQL statement and returning the results it produces.   <b>PreparedStatement </b>is a SQL statement which is precompiled and stored in a PreparedStatement object. This object can then be used to efficiently execute this statement multiple times.    There are few advantages of using PreparedStatements over Statements  <ol>\n<li>Since its pre-compiled, Executing the same query multiple times in loop, binding different parameter values each time is faster. (What does pre-compiled statement means? The prepared statement(pre-compiled) concept is not specific to Java, it is a database concept. Statement precompiling means: when you execute a SQL query, database server  will prepare a execution plan before executing the actual query, this execution plan will be cached at database server for further execution.)</li>\n<li>In PreparedStatement the setDate()/setString() methods can be used to escape dates and strings properly, in a database-independent way.</li>\n<li>SQL injection attacks on a system are virtually impossible when using PreparedStatements.</li>\n</ol>\n</p>",
            "category": "JDBC"
        },
        {
            "id": "20",
            "q": "What does setAutoCommit(false) do?",
            "a": "<p>\nA JDBC connection is created in auto-commit mode by default. This means that each individual SQL statement is treated as a transaction and will be automatically committed as soon as it is executed. If you require two or more statements to be grouped into a transaction then you need to disable auto-commit mode using below command  <pre name='code' class='java'>con.setAutoCommit(false);\n</pre>\nOnce auto-commit mode is disabled, no SQL statements will be committed until you explicitly call the commit method. A Simple transaction with use of autocommit flag is demonstrated below.  <pre name='code' class='java'>con.setAutoCommit(false);\n    PreparedStatement updateStmt =\n     con.prepareStatement( \"UPDATE EMPLOYEE SET SALARY = ? WHERE EMP_NAME LIKE ?\");\n    updateStmt.setInt(1, 5000); updateSales.setString(2, \"Jack\");\n    updateStmt.executeUpdate();\n    updateStmt.setInt(1, 6000); updateSales.setString(2, \"Tom\");\n    updateStmt.executeUpdate(); \n    con.commit();\n    con.setAutoCommit(true);\n</pre>\n</p>",
            "category": "JDBC"
        },
        {
            "id": "21",
            "q": "What are database warnings and How can I handle database warnings in JDBC?",
            "a": "<p>\nWarnings are issued by database to notify user of a problem which may not be very severe. Database warnings do not stop the execution of SQL statements. In JDBC SQLWarning is an exception that provides information on database access warnings. Warnings are silently chained to the object whose method caused it to be reported.    Warnings may be retrieved from Connection, Statement, and ResultSet objects.    Handling SQLWarning from connection object  <pre name='code' class='java'>//Retrieving warning from connection object\n SQLWarning warning = conn.getWarnings();\n \n //Retrieving next warning from warning object itself\n SQLWarning nextWarning = warning.getNextWarning();\n \n //Clear all warnings reported for this Connection object. \n conn.clearWarnings();\n</pre>\nHandling SQLWarning from Statement object  <pre name='code' class='java'>//Retrieving warning from statement object\n stmt.getWarnings();\n\n //Retrieving next warning from warning object itself\n SQLWarning nextWarning = warning.getNextWarning(); \n \n //Clear all warnings reported for this Statement object. \n stmt.clearWarnings();\n</pre>\nHandling SQLWarning from ResultSet object  <pre name='code' class='java'>//Retrieving warning from resultset object\n rs.getWarnings();\n \n //Retrieving next warning from warning object itself\n SQLWarning nextWarning = warning.getNextWarning();\n \n //Clear all warnings reported for this resultset object. \n rs.clearWarnings();\n</pre>\nThe call to <b>getWarnings()</b> method in any of above way retrieves the first warning reported by calls on this object. If there is more than one  warning, subsequent warnings will be chained to the first one and can be retrieved by calling the method <b>SQLWarning.getNextWarning</b> on the warning that was retrieved previously.    A call to <b>clearWarnings()</b> method  clears all warnings reported for this object. After a call to this method, the method getWarnings  returns null until a new warning is reported for this object.    Trying to call <b>getWarning()</b> on a connection after it has been closed will cause an SQLException to be thrown. Similarly, trying to retrieve a warning on a statement after it has been closed or on a result set after it has been closed will cause an SQLException to be thrown. Note that closing a statement also closes a result set that it might have produced.\n</p>",
            "category": "JDBC"
        },
        {
            "id": "22",
            "q": "What is Metadata and why should I use it?",
            "a": "<p>\nJDBC API has 2 Metadata interfaces DatabaseMetaData & ResultSetMetaData.  The DatabaseMetaData provides Comprehensive information about the database as a whole. This interface is implemented by driver vendors to let users know the capabilities of a Database Management System (DBMS) in combination with the driver based on JDBC technology (\"JDBC driver\") that is used with it. Below is a sample code which demonstrates how we can use the DatabaseMetaData   <pre name='code' class='java'>DatabaseMetaData md = conn.getMetaData();\n System.out.println(\"Database Name: \" + md.getDatabaseProductName());\n System.out.println(\"Database Version: \" + md.getDatabaseProductVersion());\n System.out.println(\"Driver Name: \" + md.getDriverName());\n System.out.println(\"Driver Version: \" + md.getDriverVersion());\n</pre>\nThe ResultSetMetaData is an object that can be used to get information about the types and properties of the columns in a ResultSet object.   Use DatabaseMetaData to find information about your database, such as its capabilities and structure. Use ResultSetMetaData to find information about the results of an SQL query, such as size and types of columns. Below a sample code which demonstrates how we can use the ResultSetMetaData  <pre name='code' class='java'>ResultSet rs = stmt.executeQuery(\"SELECT a, b, c FROM TABLE2\");\n     ResultSetMetaData rsmd = rs.getMetaData();\n     int numberOfColumns = rsmd.getColumnCount();\n     boolean b = rsmd.isSearchable(1);\n</pre>\n</p>",
            "category": "JDBC"
        },
        {
            "id": "23",
            "q": "What is RowSet? or What is the difference between RowSet and ResultSet? or Why do we need RowSet? or What are the advantages of using RowSet over ResultSet?",
            "a": "<p>\nRowSet is a interface that adds support to the JDBC API for the JavaBeans component model. A rowset, which can be used as a JavaBeans component in a visual Bean development environment, can be created and configured at design time and executed at run time. The RowSet  interface provides a set of JavaBeans properties that allow a RowSet  instance to be configured to connect to a JDBC data source and read some data from the data source. A group of setter methods (setInt, setBytes, setString, and so on) provide a way to pass input parameters to a rowset's command property. This command is the SQL query the rowset uses when it gets its data from a relational database, which is generally the case.   Rowsets are easy to use since the RowSet interface extends the standard java.sql.ResultSet interface so it has all the methods of ResultSet. There are two clear advantages of using RowSet over ResultSet  <ul>\n<li>RowSet makes it possible to use the ResultSet object as a JavaBeans component. As a consequence, a result set can, for example, be a component in a Swing application. </li>\n<li>RowSet be used to make a ResultSet object scrollable and updatable. All RowSet objects are by default scrollable and updatable. If the driver and database being used do not support scrolling and/or updating of result sets, an application can populate a RowSet object implementation (e.g. JdbcRowSet) with the data of a ResultSet object and then operate on the RowSet object as if it were the ResultSet  object.</li>\n</ul>\n</p>",
            "category": "JDBC"
        },
        {
            "id": "24",
            "q": "What is a connected RowSet? or What is the difference between connected RowSet and disconnected RowSet? or Connected vs Disconnected RowSet, which one should I use and when?",
            "a": "<p>\n<h3>\nConnected RowSet</h3>\nA RowSet object may make a connection with a data source and maintain that connection throughout its life cycle, in which case it is called a connected rowset. A rowset may also make a connection with a data source, get data from it, and then close the connection. Such a rowset is called a disconnected rowset. A disconnected rowset may make changes to its data while it is disconnected and then send the changes back to the original source of the data, but it must reestablish a connection to do so.  <b>Example of Connected RowSet:</b>  A JdbcRowSet object is a example of connected RowSet, which means it continually maintains its connection to a database using a JDBC technology-enabled driver.  <h2>\nDisconnected RowSet</h2>\nA disconnected rowset may have a reader (a RowSetReader object) and a writer (a RowSetWriter object) associated with it. The reader may be implemented in many different ways to populate a rowset with data, including getting data from a non-relational data source. The writer can also be implemented in many different ways to propagate changes made to the rowset's data back to the underlying data source.   <b>Example of Disconnected RowSet:</b>  A CachedRowSet object is a example of disconnected rowset, which means that it makes use of a connection to its data source only briefly. It connects to its data source while it is reading data to populate itself with rows and again while it is propagating changes back to its underlying data source. The rest of the time, a CachedRowSet object is disconnected, including while its data is being modified. Being disconnected makes a RowSet  object much leaner and therefore much easier to pass to another component. For example, a disconnected RowSet object can be serialized and passed over the wire to a thin client such as a personal digital assistant (PDA).\n</p>",
            "category": "JDBC"
        },
        {
            "id": "25",
            "q": "What is the benefit of having JdbcRowSet implementation? Why do we need a JdbcRowSet like wrapper around ResultSet?",
            "a": "<p>\nThe JdbcRowSet implementation is a wrapper around a ResultSet object that has following advantages over ResultSet   <ul>\n<li> This implementation makes it possible to use the ResultSet object as a JavaBeans component. A JdbcRowSet can be used as a JavaBeans component in a visual Bean development environment, can be created and configured at design time and executed at run time. </li>\n<li>It can be used to make a ResultSet object scrollable and updatable. All RowSet objects are by default scrollable and updatable. If the driver and database being used do not support scrolling and/or updating of result sets, an application can populate a JdbcRowSet object with the data of a ResultSet object and then operate on the JdbcRowSet object as if it were the ResultSet object. </li>\n</ul>\n</p>",
            "category": "JDBC"
        },
        {
            "id": "26",
            "q": "What is Java Collections API?",
            "a": "Java Collections framework API is a unified architecture for representing and manipulating collections. The API contains Interfaces, Implementations &amp; Algorithm to help java programmer in everyday programming. In nutshell, this API does 6 things at high level         <ul>\n<li>Reduces programming efforts. - Increases program speed and quality.</li>\n<li>Allows interoperability among unrelated APIs. </li>\n<li> Reduces effort to learn and to use new APIs. </li>\n<li> Reduces effort to design new APIs. </li>\n<li> Encourages &amp; Fosters software reuse. </li>\n</ul>\nTo be specific, There are six collection java interfaces. The most basic interface is Collection. Three interfaces extend Collection: Set, List, and SortedSet. The other two collection interfaces, Map and SortedMap, do not extend Collection, as they represent mappings rather than true collections.",
            "category": "Collections Framework"
        },
        {
            "id": "27",
            "q": "What is an Iterator?",
            "a": "Some of the collection classes provide traversal of their contents via a java.util.Iterator interface. This interface allows you to walk through a collection of objects, operating on each object in turn. Remember when using Iterators that they contain a snapshot of the collection at the time the Iterator was obtained; generally it is not advisable to modify the collection itself while traversing an Iterator.",
            "category": "Collections Framework"
        },
        {
            "id": "28",
            "q": "What is the difference between java.util.Iterator and java.util.ListIterator?",
            "a": "<ul>\n<li><b>Iterator</b> : Enables you to traverse through a collection in the forward direction only, for obtaining or removing elements</li>\n<li><b>ListIterator</b> : extends Iterator, and allows bidirectional traversal of list and also allows the modification of elements.</li>\n</ul>",
            "category": "Collections Framework"
        },
        {
            "id": "29",
            "q": "What is HashMap and Map? ",
            "a": "<p>Map is Interface which is part of Java collections framework. This is to store Key Value pair, and Hashmap is class that implements that using hashing technique.</p>",
            "category": "Collections Framework"
        },
        {
            "id": "30",
            "q": "Difference between HashMap and HashTable? Compare Hashtable vs HashMap?",
            "a": "Both Hashtable and HashMap provide key-value access to data. The Hashtable is one of the original collection classes in Java (also called as legacy classes). HashMap is part of the new Collections Framework, added with Java 2, v1.2. There are several differences between HashMap and Hashtable in Java as listed below         <ul>\n<li>The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls. (HashMap allows null values as key and value whereas Hashtable doesn’t allow nulls). </li>\n<li>HashMap does not guarantee that the order of the map will remain constant over time. But one of HashMap's subclasses is LinkedHashMap, so in the event that you'd want predictable iteration order (which is insertion order by default), you can easily swap out the HashMap for a LinkedHashMap. This wouldn't be as easy if you were using Hashtable. </li>\n<li>HashMap is non synchronized whereas Hashtable is synchronized. </li>\n<li>Iterator in the HashMap is fail-fast while the enumerator for the Hashtable isn't. So this could be a design consideration. </li>\n</ul>",
            "category": "Collections Framework"
        },
        {
            "id": "31",
            "q": "What does synchronized means in Hashtable context?",
            "a": "Synchronized means only one thread can modify a hash table at one point of time.  Any thread before performing an update on a hashtable will have to acquire a lock on the object while others will wait for lock to be released.",
            "category": "Collections Framework"
        },
        {
            "id": "32",
            "q": "What is fail-fast property?",
            "a": "<p>At high level - Fail-fast is a property of a system or software with respect to its response to failures. A fail-fast system is designed to immediately report any failure or condition that is likely to lead to failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly-flawed process.   \n\nWhen a problem occurs, a fail-fast system fails immediately and visibly. Failing fast is a non-intuitive technique: \"failing immediately and visibly\" sounds like it would make your software more fragile, but it actually makes it more robust. Bugs are easier to find and fix, so fewer go into production.   \n\nIn Java, Fail-fast term can be related to context of iterators. If an iterator has been created on a collection object and some other thread tries to modify the collection object \"structurally\", a concurrent modification exception will be thrown.  \n\nIt is possible for other threads though to invoke \"set\" method since it doesn't modify the collection \"structurally\".  However, if prior to calling \"set\", the collection has been modified structurally, \"IllegalArgumentException\" will be thrown.</p>",
            "category": "Collections Framework"
        },
        {
            "id": "33",
            "q": "Why doesn't Collection extend Cloneable and Serializable?",
            "a": "<p>\nFrom Sun FAQ Page:  Many Collection implementations (including all of the ones provided by the JDK) will have a public clone method, but it would be mistake to require it of all Collections.\n\nFor example, what does it mean to clone a Collection that's backed by a terabyte SQL database? Should the method call cause the company to requisition a new disk farm? Similar arguments hold for serializable.  \n\nIf the client doesn't know the actual type of a Collection, it's much more flexible and less error prone to have the client decide what type of Collection is desired, create an empty Collection of this type, and use the addAll method to copy the elements of the original collection into the new one. \n\n<b>Note on Some Important Terms</b>       \n<ul>\n<li>Synchronized means only one thread can modify a hash table at one point of time. Basically, it means that any thread before performing an update on a hashtable will have to acquire a lock on the object while others will wait for lock to be released. </li>\n<li>Fail-fast is relevant from the context of iterators. If an iterator has been created on a collection object and some other thread tries to modify the collection object \"structurally”, a concurrent modification exception will be thrown. It is possible for other threads though to invoke \"set\" method since it doesn’t modify the collection \"structurally”. However, if prior to calling \"set\", the collection has been modified structurally, \"IllegalArgumentException\" will be thrown. </li>\n</ul>\n</p>",
            "category": "Collections Framework"
        },
        {
            "id": "34",
            "q": "How can we make Hashmap synchronized?",
            "a": "\nHashMap can be synchronized by  <i>Map m = Collections.synchronizedMap(hashMap);</i>\n",
            "category": "Collections Framework"
        },
        {
            "id": "35",
            "q": "Where will you use Hashtable and where will you use HashMap?",
            "a": "<h3>There Are Multiple Aspects To This Decision:</h3>\n<ul><li>The basic difference between a Hashtable and an HashMap is that, Hashtable is synchronized while HashMap is not. Thus whenever there is a possibility of multiple threads accessing the same instance, one should use Hashtable. While if not multiple threads are going to access the same instance then use HashMap. Non synchronized data structure will give better performance than the synchronized one. </li><li>If there is a possibility in future that - there can be a scenario when you may require to retain the order of objects in the Collection with key-value pair then HashMap can be a good choice. As one of HashMap's subclasses is LinkedHashMap, so in the event that you'd want predictable iteration order (which is insertion order by default), you can easily swap out the HashMap for a LinkedHashMap. This wouldn't be as easy if you were using Hashtable. Also if you have multiple thread accessing you HashMap then Collections.synchronizedMap() method can be leveraged.  Overall HashMap gives you more flexibility in terms of possible future changes.</li></ul>",
            "category": "Collections Framework"
        },
        {
            "id": "36",
            "q": "Difference between Vector and ArrayList? What is the Vector class?",
            "a": "<p>\nVector and ArrayList both classes are implemented using dynamically resizable arrays, providing fast random access and fast traversal. ArrayList and Vector class both implement the List interface. Both the classes are member of Java collection framework, therefore from an API perspective, these two classes are very similar. However, there are still some major differences between the two. Below are some key differences          <ul>\n<li>Vector is a legacy class which has been retrofitted to implement the List interface since Java 2 platform v1.2</li>\n<li>Vector is synchronized whereas ArrayList is not. Even though Vector class is synchronized, still when you want programs to run in multithreading environment using ArrayList with Collections.synchronizedList() is recommended over Vector.</li>\n<li> ArrayList has no default size while vector has a default size of 10.</li>\n<li>The Enumerations returned by Vector's elements method are not  fail-fast. Whereas ArraayList does not have any method returning Enumerations.</li>\n</ul>\n</p>",
            "category": "Collections Framework"
        },
        {
            "id": "37",
            "q": "What is the Difference between Enumeration and Iterator interface?",
            "a": "<p>\nEnumeration and Iterator are the interface available in java.util package. The functionality of Enumeration interface is duplicated by the Iterator interface. New implementations should consider using Iterator in preference to Enumeration.  Iterators differ from enumerations in following ways:  <ol>\n<li> Enumeration contains 2 methods namely hasMoreElements() & nextElement() whereas Iterator contains three methods namely hasNext(), next(),remove().</li>\n<li> Iterator adds an optional remove operation, and has shorter method names. Using remove() we can delete the objects but Enumeration interface does not support this feature.</li>\n<li> Enumeration interface is used by legacy classes. Vector.elements() & Hashtable.elements() method returns Enumeration.  Iterator is returned by all Java Collections Framework classes. java.util.Collection.iterator() method returns an instance of Iterator.</li>\n</ol>\n</p>\n",
            "category": "Collections Framework"
        },
        {
            "id": "38",
            "q": "Why Java Vector class is considered obsolete or unofficially deprecated? or Why should I always use ArrayList over Vector?",
            "a": "<p>\nYou should use ArrayList over Vector because you should default to non-synchronized access. Vector synchronizes each individual method. That's almost never what you want to do. Generally you want to synchronize a whole sequence of operations.  \n\nSynchronizing individual operations is both less safe (if you iterate over a Vector, for instance,  you still need to take out a lock to avoid anyone else changing the collection at the same time)  but also slower (why take out a lock repeatedly when once will be enough)?  Of course, it also has the overhead of locking even when you don't need to. It's a very flawed approach to have synchronized access as default.  \n\nYou can always decorate a collection using Collections.synchronizedList -  the fact that Vector combines both the \"resized array\" collection implementation with the  \"synchronize every operation\" bit is another example of poor design;  the decoration approach gives cleaner separation of concerns.  \n\nVector also has a few legacy methods around enumeration and element retrieval which are different than the List interface,  and developers (especially those who learned Java before 1.2) can tend to use them if they are in the code.  Although Enumerations are faster, they don't check if the collection was modified during iteration, which can cause issues,  and given that Vector might be chosen for its syncronization - with the attendant access from multiple threads, this makes it a particularly pernicious problem.  \n\nUsage of these methods also couples a lot of code to Vector, such that it won't be easy to replace it with a different List implementation.  Despite all above reasons Sun may never officially deprecate Vector class. (Read details <a href=\"http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6201870\">Deprecate Hashtable and Vector</a>)\n</p>\n",
            "category": "Collections Framework"
        },
        {
            "id": "39",
            "q": "What is an enumeration?",
            "a": "An enumeration is an interface containing methods for accessing the underlying data structure from which the enumeration is obtained. It is a construct which collection classes return when you request a collection of all the objects stored in the collection. It allows sequential access to all the elements stored in the collection.",
            "category": "Collections Framework"
        },
        {
            "id": "40",
            "q": "What is the difference between Enumeration and Iterator?",
            "a": "The functionality of Enumeration interface is duplicated by the Iterator interface. Iterator has a remove() method while Enumeration doesn't. Enumeration acts as Read-only interface, because it has the methods only to traverse and fetch the objects, where as using Iterator we can manipulate the objects also like adding and removing the objects.  So Enumeration is used when ever we want to make Collection objects as Read-only.",
            "category": "Collections Framework"
        },
        {
            "id": "41",
            "q": "Where will you use Vector and where will you use ArrayList?",
            "a": "The basic difference between a Vector and an ArrayList is that, vector is synchronized while ArrayList is not. Thus whenever there is a possibility of multiple threads accessing the same instance, one should use Vector. While if not multiple threads are going to access the same instance then use ArrayList. Non synchronized data structure will give better performance than the synchronized one.",
            "category": "Collections Framework"
        },
        {
            "id": "42",
            "q": "What is the importance of hashCode() and equals() methods? How they are used in Java?",
            "a": "<p>\nThe hashCode() method returns a hash code value for the object. This method is supported for the benefit of hashtables such as those provided by java.util.Hashtable or java.util.HashMap.  \n\nThe general contract of hashCode is:   Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.   \n\nIf two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.  \n\nIt is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hashtables. \n\nAs much as is reasonably practical, the hashCode method defined by class Object does return distinct integers for distinct objects.  The equals(Object obj) method indicates whether some other object is \"equal to\" this one.  \n</p>\n<h3>The equals Method</h3>\n<p>\nThe equals method implements an equivalence relation on non-null object references:   \n\nIt is reflexive: for any non-null reference value x, x.equals(x) should return true.   \nIt is symmetric: for any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.   \nIt is transitive: for any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.   \nIt is consistent: for any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the objects is modified.  \n\nFor any non-null reference value x, x.equals(null) should return false.  The equals method for class Object implements the most discriminating possible equivalence relation on objects; that is, for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true).  Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes.  \n</p>\n<h3>A practical Example of hashcode() and equals(): </h3><p> This can be applied to classes that need to be stored in Set collections. Sets use equals() to enforce non-duplicates, and HashSet uses hashCode() as a first-cut test for equality. Technically hashCode() isn't necessary then since equals() will always be used in the end, but providing a meaningful hashCode() will improve performance for very large sets or objects that take a long time to compare using equals().</p>\n\n</p>",
            "category": "Collections Framework"
        },
        {
            "id": "43",
            "q": "What is the difference between Sorting performance of Arrays.sort() vs Collections.sort() ? Which one is faster? Which one to use and when?",
            "a": "<p>\nMany developers are concerned about the performance difference between java.util.Array.sort() java.util.Collections.sort() methods.   Both methods have same algorithm the only difference is type of input to them.  Collections.sort() has a input as List so it does a translation of List to array and vice versa which is an additional step while sorting. \n\nSo this should be used when you are trying to sort a list.  Arrays.sort is for arrays so the sorting is done directly on the array. So clearly it should be used when you have a array available with you and you want to sort it.\n</p>\n",
            "category": "Collections Framework"
        },
        {
            "id": "44",
            "q": "What is java.util.concurrent BlockingQueue? How it can be used?",
            "a": "<p>\nJava has implementation of BlockingQueue available since Java 1.5. Blocking Queue interface extends collection interface, which provides you power of collections inside a queue. Blocking Queue is a type of Queue that additionally supports operations that wait for the queue to become non-empty when retrieving an element, and wait for space to become available in the queue when storing an element. \n\nA typical usage example would be based on a producer-consumer scenario. Note that a BlockingQueue can safely be used with multiple producers and multiple consumers.  An ArrayBlockingQueue is a implementation of blocking queue with an array used to store the queued objects. The head of the queue is that element that has been on the queue the longest time. \n\nThe tail of the queue is that element that has been on the queue the shortest time. New elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue.  \n\nArrayBlockingQueue requires you to specify the capacity of queue at the object construction time itself. Once created, the capacity cannot be increased.  This is a classic \"bounded buffer\" (fixed size buffer), in which a fixed-sized array holds elements inserted by producers and extracted by consumers. Attempts to put an element to a full queue will result in the put operation blocking; attempts to retrieve an element from an empty queue will be blocked.\n</p>",
            "category": "Collections Framework"
        },
        {
            "id": "45",
            "q": "Set and List interface extend Collection, so Why doesn't Map interface extend Collection?",
            "a": "<p>\nThough the Map interface is part of collections framework, it does not extend collection interface. This is by design, and the answer to this questions is best described in Sun's FAQ Page:  This was by design. We feel that mappings are not collections and collections are not mappings. Thus, it makes little sense for Map to extend the Collection interface (or vice versa).  \n\nIf a Map is a Collection, what are the elements? The only reasonable answer is \"Key-value pairs\", but this provides a very limited (and not particularly useful) Map abstraction. You can't ask what value a given key maps to, nor can you delete the entry for a given key without knowing what value it maps to.   \n\nCollection could be made to extend Map, but this raises the question: what are the keys? There's no really satisfactory answer, and forcing one leads to an unnatural interface.   Maps can be viewed as Collections (of keys, values, or pairs), and this fact is reflected in the three \"Collection view operations\" on Maps (keySet, entrySet, and values).\n\nWhile it is, in principle, possible to view a List as a Map mapping indices to elements, this has the nasty property that deleting an element from the List changes the Key associated with every element before the deleted element. That's why we don't have a map view operation on Lists.\n</p>",
            "category": "Collections Framework"
        },
        {
            "id": "46",
            "q": "Which implementation of the List interface provides for the fastest insertion of a new element into the middle of the list?",
            "a": "\nList interface has three main implementation classes \n\n<p><ul><li>Vector</li><li>ArrayList </li><li>LinkedList</li></ul>\n\nArrayList and Vector both use an array to store the elements of the list. When an element is inserted into the middle of the list the elements that follow the insertion point must be shifted to make room for the new element. \n\nThe LinkedList is implemented using a doubly linked list; an insertion requires only the updating of the links at the point of insertion. Therefore, the LinkedList allows for fast insertions and deletions.</p>",
            "category": "Collections Framework"
        },
        {
            "id": "47",
            "q": "What is the difference between ArrayList and LinkedList? (ArrayList vs LinkedList.)",
            "a": "<p>\njava.util.ArrayList and java.util.LinkedList are two Collections classes used for storing lists of object references  <b>Here are some key differences:</b>       <ul>\n<li> ArrayList uses primitive object array for storing objects   whereas LinkedList is made up of a chain of nodes. Each node stores an element and the pointer to the next node. A singly linked list only has pointers to next. A doubly linked list has a pointer to the next and the previous element. This makes walking the list backward easier.</li>\n<li>ArrayList implements the RandomAccess interface, and LinkedList does not. The commonly used ArrayList implementation uses primitive Object array for internal storage. Therefore an ArrayList is much faster than a LinkedList for random access, that is, when accessing arbitrary list elements using the get method.   Note that the get method is implemented for LinkedLists, but it requires a sequential scan from the front or back of the list.  This scan is very slow. For a LinkedList, there's no fast way to access the Nth element of the list.</li>\n<li>Adding and deleting at the start and middle of the ArrayList is slow, because all the later elements have to be copied forward or backward. (Using System.arrayCopy())  Whereas Linked lists are faster for inserts and deletes anywhere in the list, since all you do is update a few next and previous pointers of a node.</li>\n<li>Each element of a linked list (especially a doubly linked list) uses a bit more memory than its equivalent in array list, due to the need for next and previous pointers.</li>\n<li> ArrayList may also have a performance issue when the internal array fills up. The arrayList has to create a new array and copy all the elements there.  The ArrayList has a growth algorithm of (n*3)/2+1, meaning that each time the buffer is too small it will create a new one of size (n*3)/2+1 where n is the number of elements of the current buffer.  Hence if we can guess the number of elements that we are going to have, then it makes sense to create a arraylist with that capacity during object creation (using construtor new ArrayList(capacity)).  Whereas LinkedLists should not have such capacity issues.</li>\n</ul>\n</p>",
            "category": "Collections Framework"
        },
        {
            "id": "48",
            "q": "Where will you use ArrayList and Where will you use LinkedList? Or Which one to use when (ArrayList / LinkedList).",
            "a": "<p>\nBelow is a snippet from SUN's site.  \n\n<blockquote>The Java SDK contains 2 implementations of the List interface - ArrayList and LinkedList. If you frequently add elements to the beginning of the List or iterate over the List to delete elements from its interior, you should consider using LinkedList.  These operations require constant-time in a LinkedList and linear-time in an ArrayList. But you pay a big price in performance.  Positional access requires linear-time in a LinkedList and constant-time in an ArrayList.</blockquote>\n</p>\n",
            "category": "Collections Framework"
        },
        {
            "id": "49",
            "q": "What is performance of various Java collection implementations/algorithms? What is Big 'O' notation for each of them ?",
            "a": "<p>Each java collection implementation class have different performance for different methods, which makes them suitable for different programming needs.  \n<h2>Performance of Map interface implementations</h2>\n<h3>\nHashtable</h3>\nAn instance of Hashtable has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. Note that the hash table is open: in the case of a \"hash collision\", a single bucket stores multiple entries, which must be searched sequentially. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. The initial capacity and load factor parameters are merely hints to the implementation. The exact details as to when and whether the rehash method is invoked are implementation-dependent.  <h3>\nHashMap </h3>\nThis implementation provides constant-time [ Big O Notation is O(1) ] performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets. Iteration over collection views requires time proportional to the \"capacity\" of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings).  Thus, it's very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important.   <h3>\nTreeMap</h3>\nThe TreeMap implementation provides guaranteed log(n) [ Big O Notation is O(log N) ] time cost for the containsKey, get, put and remove operations.  <h3>\nLinkedHashMap</h3>\nA linked hash map has two parameters that affect its performance: initial capacity and load factor. They are defined precisely as for HashMap. Note, however, that the penalty for choosing an excessively high value for initial capacity is less severe for this class than for HashMap, as iteration times for this class are unaffected by capacity.\n\n<h2>Performance of Set interface implementations</h2>\n\n<h3>HashSet</h3>\nThe HashSet class offers constant-time [ Big O Notation is O(1) ] performance for the basic operations (add, remove, contains and size), assuming the hash function disperses the elements properly among the buckets. Iterating over this set requires time proportional to the sum of the HashSet instance's size (the number of elements) plus the \"capacity\" of the backing HashMap instance (the number of buckets). Thus, it's very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important.   <h3>\nTreeSet</h3>\nThe TreeSet implementation provides guaranteed log(n) time cost for the basic operations (add, remove and contains).    <h3>\nLinkedHashSet</h3>\nA linked hash set has two parameters that affect its performance: initial capacity and load factor. They are defined precisely as for HashSet. Note, however, that the penalty for choosing an excessively high value for initial capacity is less severe for this class than for HashSet, as iteration times for this class are unaffected by capacity.\n<h2>\nPerformance of List interface implementations</h2>\n<h3>\nLinkedList</h3>\n- Performance of get and remove methods is linear time [ Big O Notation is O(n) ]  - Performance of add and Iterator.remove methods is  constant-time [ Big O Notation is  O(1) ]         <h3>\nArrayList</h3>\n- The size, isEmpty, get, set, iterator, and listIterator operations run in constant time. [ Big O Notation is  O(1) ]  - The add operation runs in amortized constant time [ Big O Notation is  O(1) ] , but in worst case (since the array must be resized and copied) adding n elements requires linear time [ Big O Notation is O(n) ]  - Performance of remove method is linear time [ Big O Notation is O(n) ]  - All of the other operations run in linear time [ Big O Notation is O(n) ]. The constant factor is low compared to that for the LinkedList implementation.</p>",
            "category": "Collections Framework"
        },
        {
            "id": "111",
            "q": "Need Help in learning Java?",
            "a": "Visit <href='http://www.fromdev.com/2012/11/Best-Way-To-Learn-Java.html'>how to learn Java </a> page to get some guidelines on how to get started.",
            "category": "More"
        },
        {
            "id": "112",
            "q": "Looking for more Java questions?",
            "a": "Go to - Home - More - Update Questions - Update. This will update the questions to get latest set of questions available in this list.",
            "category": "More"
        },
        {
            "id": "113",
            "q": "Looking for Java interview preparation books?",
            "a": "We have created a list of best books that can help you learn java and become expert Java developer. Visit this page : <a href='http://www.fromdev.com/2011/04/5-best-core-java-books-you-must-read-as.html'>Best Java Books</a>",
            "category": "More"
        },
        {
            "id": "114",
            "q": "Looking for programming interview preparation books?",
            "a": "We have created a list of best books that can help you prepare for jobs at companies like Google, Apple and Microsoft. Visit this page : <a href='http://www.fromdev.com/2013/07/interview-questions-book.html'>Best Interview Preparation Books</a>",
            "category": "More"
        },
        {
            "id": "115",
             "q": "Need to discuss any question or answer?",
            "a": "Visit <href='http://www.fromdev.com/2012/02/java-interview-question-answer.html'>FromDev.com</a> to discuss and get help.",
            "category": "More"
       },
        {
            "id": "116",
            "q": "Have feedback about something on this app?",
            "a": "Your feedback is always welcome. We are constantly trying to improve this app. Can you think of a questions which is not part of this post? Please don't forget to share it with me in comments section & I will try to include it in the list. To Sent Feedback or a new question. Go to - Home - More - Feedback. and send us your feedback. ",
            "category": "More"
        }
        
    ]
}
